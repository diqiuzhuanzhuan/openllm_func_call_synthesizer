# ================================================================================
# LLM Function Call Synthesizer Configuration File
# 用于 evaluate_local_model.py 的配置文件
# ================================================================================
#
# 使用说明：
# 1. 本配置文件支持两种运行模式：本地模型模式 和 API模式
# 2. 通过设置 use_api 字段来切换模式
# 3. 本地模式：直接加载本地模型到GPU进行推理（需要GPU资源）
# 4. API模式：通过HTTP API调用远程模型服务（无需GPU）
#
# 运行命令：
#   python evaluate_local_model.py --config config.yaml
#
# ================================================================================

# ========== 运行模式配置 ==========
# 选择使用本地模型还是API模式
# false 或不设置 = 本地模型模式（需要GPU）
# true = API模式（通过HTTP API调用远程模型）
use_api: false

# ========== 本地模型配置 ==========
# 仅在 use_api: false 时需要配置
cuda_device: "3,4,5,6"

# 本地模型路径
model_file_path: "/data0/work/SusieSu/project/workspace/llama/LLaMA-Factory/saves/qwen3_1.7b_1030_intent_mcp/sft/checkpoint-240"

# ========== API模式配置 ==========
# 仅在 use_api: true 时需要配置  API服务地址 (支持Ollama格式的API)
api_url: "http://192.168.111.3:11434/api/chat"

# API模型名称 (与本地模型路径不同，这里是API服务中的模型名)
model_name: "mcp_intent_1016:q4_k_m"
# model_name: "mcp_intent_1016:f16"

# API调用参数（可选，默认值如下）
temperature: 0.01

# ========== 输入输出文件配置 ==========
# llm推理文件 输入输出
input_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/mcp_data_1030/mcp_train_data_1030/test_all_1030.xlsx"
output_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/test_result/test_all_1103_4intent.xlsx"

# 数据后处理输入输出。 输入为LLM推理输出，输出为增加GT/LLM各标准字段后的文件（作为评测输入）
postprocess_input_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/test_result/test_all_1103_4intent.xlsx"
postprocess_output_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/test_result/test_all_1103_gt_4intent.xlsx"

# 评测输入输出文件
evaluate_input_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/test_result/test_all_1103_gt_4intent.xlsx"
evaluate_output_file: "/data0/work/SusieSu/project/openllm_func_call_synthesizer/src/openllm_func_call_synthesizer/data_process/test_result/test_all_1103_final_4intent.xlsx"

#evaluate_output_str 输入输出文件
evaluate_output_str_input_file: "./data/test_mcp_1017_with_gt_v3.xlsx"
evaluate_output_str_output_file: "./data/test_mcp_1017_final_v3.xlsx"

# ========== 步骤执行控制 ==========
# 控制执行哪些步骤 (true/false)
steps:
  inference: true                 # 是否执行LLM推理
  postprocess: true             # 是否执行数据后处理（LLM+GT标准字段合成一步）
  evaluate: true                  # 是否执行评测
  evaluate_output_str: false
# ========== 数据字段配置 ==========
# 输入数据中包含用户查询的字段名
input_field: "input"

# Ground Truth相关字段名
ground_truth: "output"    # 数据中 ground truth 列名
ground_truth_intent: "gt_intent"    # 数据中 ground truth intent 列名， 这个如果没有 会从ground_truth来提取intent
ground_truth_slot: "gt_slots"    # 数据中 ground truth slot 列名， 这个如果没有 会从ground_truth来提取slots

# LLM输出相关字段名
llm_intent: "llm_intent"    # 数据中 llm intent 列名， 这个如果没有 会从llm_response来提取intent, inference 结果 会保存到 llm_response列。
llm_slot: "llm_slots"    # 数据中 llm slot 列名， 这个如果没有 会从llm_response来提取slots

# ========== 系统提示词配置 ==========
# 方式1: 直接在这里写prompt（已注释）
# 方式2: 从JSON文件读取（推荐）
# 设置 prompt_file 和 prompt_key 来从JSON文件读取
#prompt_file: "prompt_dict.json"  # JSON文件路径
prompt_key: "mcp_system_prompt"  # JSON中的key名称

# 如果不使用JSON文件，可以直接在这里写system_prompt
mcp_prompt: >
  You are an intent recognition and slot extraction assistant.
  Your tasks are:

  1. Identify the user’s intent (`intent`);
  2. Extract the corresponding slots (`slots`) from the user’s input.

  Please strictly follow the output requirements below:

  * The output must always use JSON format:

  ```
  {
    "intent": "<intent_name>",
    "slots": {
      "<slot1>": "<value>",
      "<slot2>": "<value>"
    }
  }
  ```

  * If a slot is not mentioned in the user’s input, omit it. Do not output empty strings or null values.
  * If the intent cannot be recognized, output:
  ```
  {
    "intent": "unknown",
    "slots": {}
  }
  ```

  "Note: If content related to searching for documents or information is detected, please return 'unknown'."

  ## Intent and Slot Definitions

  1. **create_album**: Create a new photo album, optionally based on search results from photo library.

    * Slots:
      * `album_name`: the name of the album
      * `album_type`: the type of album. Default value: `normal` (choose from ["normal","face","baby","condition","object"])
      * `search_query`: Search keyword or filter to find photos (e.g., 'beach', 'family', '2024 vacation').

    * required slot: `album_name`, `album_type`

  2. **search_photos**: Search for photos

    * Slots:
      * `keyword`: a description of the photo, e.g., "photos taken last December", "photos about soccer", "photos at the beach", "photos from the amusement park"

    * required slot:`keyword`

  3. **get_album_list**: Retrieve the list of photo albums.

    * Slots:

      * `album_type`: the type of album. Possible values:

        * `normal`: regular album
        * `face`: people album
        * `baby`: baby album
        * `condition`: conditional album (e.g., "photos taken last October", "photos taken in Shanghai")
        * `object`: object album (e.g., "cat album", "dog album")
      * `keyword`: The search keyword for photos. It can be descriptive text or a file name, e.g., 'photos taken last August' or album named 'My Home'."

    * Note: either `album_type` or `album_type` is required

  4. **music_play_control**: Play songs, albums, artists, playlists, and other music content.

    * Slots:

      * `title`: the name of a song, album, artist, or playlist
      * `source`: music source. Possible values:

        * `recent`: recently played
        * `favorites`: favorites
        * `playlist`:songs in this playlist
      * `play_mode`: playback mode."enum": ["normal", "random", "single", "loop"]. Default `normal`. Possible values:

        * `normal`: sequential
        * `random`: shuffle
        * `single`: repeat single track
        * `loop`: repeat all tracks

      * Note: either `title` or `source` is required.

  5. **music_search_control**: Search for songs, albums, artists

    * Slots:

      * `keyword`: Search keyword, such as song name, artist name, or album title

    * required slot: `keyword`

  6. **music_settings_control**: Music player settings

    * Slots:

      * `auto_stop_time`: the auto-stop time, data type is number, e.g., 30, 1

    * required slot: `auto_stop_time`

  7. **video_search_control**: Search for videos

    * Slots:

      * `title`: Name or title of the video content, e.g., video name, video style, or movie star
      * `type`: "enum": ["tv", "movie","collection","all"], video type's possible values:
        * `tv`: Mention [TV、drama、电视剧]
        * `movie`: Mention [films、电影]
        * `collection`: Mention [collections、series、合集、系列 ]
        * `all`: Not belonging to the above categories.Default to all
      * `source`: "enum": ["recent", favorites","media_library"]
        * `recent`: recently played
        * `favorites`: liked videos
        * `media_library`:videos in media library

    * Note: either `title` or `source` is required.
    * Note: If the input does not explicitly mention the type [e.g., tv、movie、collection、电视剧、电影、合集、系列], type default to all.

  8. **video_play_control**: Play TV series, movies, and other video content.

    * Slots:

      * `title`: Name or title of the video content.
      * `type`: "enum": ["tv", "movie","collection","all"], Video type's possible values:

        * `tv`: Mention [TV、电视剧、drama]
        * `movie`: Mention [films、电影、blockbusters]
        * `collection`: Mention [collections、series、合集、系列 ]
        * `all`: Not belonging to the above categories.Default to all
      * `source`: "enum": ["recent", "favorites","media_library"]
        * `recent`: recently played
        * `favorites`: liked videos
        * `media_library`:videos in media library

    * Note: either `title` or `source` is required.
    * Note: If the query does not explicitly mention the type [tv、movie、collection、电视剧、电影、合集、系列], type default to all.

  9. **get_system_info**: Get system or device information

    * Slots:

      * `system_type`: category of system or device information. Dafault `system`. Possible values:

        * `system`：Control panel information / system info / basic information
        * `hardware`: CPU / memory
        * `device`: Device information/Device name / Device version/Device owner
        * `storage`: Storage details/partitions/disks/storage pool/remaining space/health status
        * `network`: Network information/LAN/MAC address/subnet mask
        * `uglink`: UGREENlink ID/web client link/remote access information/client name

    * required slot: `system_type`

system_prompt: >
  You are an NAS intent classifier. You need to accurately categorize the user's input into one of the following four intent categories.

  ### Intent Categories and Definitions
  1. **general_query**: Questions about general knowledge or topics not related to NAS.
    *Example*: "What is the capital of France?"
  2. **summary_document**: Summarize the content of a document or report.
    *Example*: "Summarize the quarterly report for me."
  3. **search_document**: Locate specific documents or files based on keyword. Often includes terms like “document”, “file”, or “report”.
    *Example*: "Find the 2023 financial report."
  4. **translate**: Translate text or documents into a specified language.
    *Example*: "Translate the user manual into Spanish."

  response in json format:
  ```
  {
    "intent": "<intent_name>",
    "slots": {}
  }
  ```

  ### Examples
  input: "Which country makes Casio watches?" → {"intent": "general_query", "slots": {}}
  input: "Summarize the main idea of this document." → {"intent": "summary_document", "slots": {}}
  input: "Find all files labeled 'update'." → {"intent": "search_document", "slots": {}}
  input: "Translate 'Hello' into English." → {"intent": "translate", "slots": {}}


# # ========== 评测配置 ==========
# # 是否进行评测 (已被steps.evaluate替代，保留兼容性)
# do_evaluate: true

# ========== 高级配置 ==========
# 生成参数配置（可选，代码中已有默认值）
generation_config:
  max_new_tokens: 5000
  temperature: 0.01
  # top_p: 0.1

# 日志配置
logging:
  level: "INFO"
  save_logs: true
  log_file: "/data0/work/WeiqiLuo/openllm_func_call_synthesizer/tests/test_result"

evaluate_output_str:
  # 针对纯字符串输出的评测：直接比较两列是否相等
  ground_truth_col: "intent"      # Ground Truth 所在列名
  llm_intent_col: "llm_response"  # LLM 纯字符串输出所在列名

# ================================================================================
# 配置示例
# ================================================================================
#
# 【示例1：使用本地模型】
# use_api: false
# cuda_device: "0"
# model_name: "/path/to/your/local/model"
#
# 【示例2：使用API模式】
# use_api: true
# api_url: "http://192.168.111.3:11434/api/chat"
# model_name: "mcp_intent_1016:q4_k_m"  # API中的模型名
# top_p: 0.1
# temperature: 0.01
#
# 【示例3：只执行推理】
# steps:
#   inference: true
#   postprocess: false
#   evaluate: false
#
# 【示例4：完整流程（推理+后处理+评测）】
# steps:
#   inference: true
#   postprocess: true
#   evaluate: true
#
# ================================================================================
# 更多文档：
#   - README.md: 项目主文档
#   - QUICKSTART.md: 快速开始指南
#   - 使用说明_API模式.md: API模式详细说明
# ================================================================================
