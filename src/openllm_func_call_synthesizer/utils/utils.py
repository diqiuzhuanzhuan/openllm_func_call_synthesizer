# MIT License
#
# Copyright (c) 2025, Loong Ma
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from typing import List, Dict, Any
from pathlib import Path
from typing import Any
import yaml
<<<<<<< HEAD
import os
=======
from fastmcp.tools import Tool
from typing import Optional, Type
from pydantic import BaseModel
from dataclasses import dataclass
from deprecated import deprecated


class DefaultToolFnSchema(BaseModel):
    """Default tool function Schema."""

    input: str

@dataclass
class ToolMetadata:
    description: str
    name: Optional[str] = None
    fn_schema: Optional[Type[BaseModel]] = DefaultToolFnSchema
    return_direct: bool = False

    def get_parameters_dict(self) -> dict:
        if self.fn_schema is None:
            parameters = {
                "type": "object",
                "properties": {
                    "input": {"title": "input query string", "type": "string"},
                },
                "required": ["input"],
            }
        else:
            parameters = self.fn_schema.model_json_schema()
            parameters = {
                k: v
                for k, v in parameters.items()
                if k in ["type", "properties", "required", "definitions", "$defs"]
            }
        return parameters

    @property
    def fn_schema_str(self) -> str:
        """Get fn schema as string."""
        if self.fn_schema is None:
            raise ValueError("fn_schema is None.")
        parameters = self.get_parameters_dict()
        return json.dumps(parameters, ensure_ascii=False)

    def get_name(self) -> str:
        """Get name."""
        if self.name is None:
            raise ValueError("name is None.")
        return self.name

    @deprecated(
        "Deprecated in favor of `to_openai_tool`, which should be used instead."
    )
    def to_openai_function(self) -> Dict[str, Any]:
        """
        Deprecated and replaced by `to_openai_tool`.
        The name and arguments of a function that should be called, as generated by the
        model.
        """
        return {
            "name": self.name,
            "description": self.description,
            "parameters": self.get_parameters_dict(),
        }

    def to_openai_tool(self, skip_length_check: bool = False) -> Dict[str, Any]:
        """To OpenAI tool."""
        if not skip_length_check and len(self.description) > 1024:
            raise ValueError(
                "Tool description exceeds maximum length of 1024 characters. "
                "Please shorten your description or move it to the prompt."
            )
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.get_parameters_dict(),
            },
        }

    def to_gemini_tool(self) -> Dict[str, Any]:
        """To Google Gemini tool."""
        return {
            "function_declarations": [
                {
                    "name": self.name,
                    "description": self.description,
                    "parameters": self.get_parameters_dict(),
                }
            ]
        }

    
def convert_to_mcp_tools(function_docs: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    tools = []
    for f in function_docs:
        func = f["function"]
        tool = {
            "name": func["name"],
            "description": func.get("description", ""),
            "input_schema": func.get("parameters", {}),
        }
        tools.append(tool)
    return {"tools": tools}


def convert_to_openai_tools(tools: List[Tool]) -> Dict[str, List[Dict[str, Any]]]:
    functions = []
    for tool in tools:
        function = {
            "type": "function",
            "function": {
                "name": tool.name,
                "description": tool.description or tool.name,
                "parameters": tool.inputSchema or {},
            }
        }
        functions.append(function)
    return {"tools": functions}


def convert_to_gemini_tools(tools: List[Tool]) -> Dict[str, List[Dict[str, Any]]]:
    functions = []
    for tool in tools:
        function = {
            "function_declarations": [
                {
                    "name": tool.name,
                    "description": tool.description or tool.name,
                    "parameters": tool.inputSchema or {},
                }
            ]
        }
        functions.append(function)
    return {"tools": functions}


def extract_format(format: str='json', content: str="") -> Any:
    import re
    import json
    if format == 'json':
        pattern = re.compile(r'```json\s*([\s\S]*?)\s*```')
        match = pattern.search(content)
        if match:
            try:
                data = json.loads(match.group(1))
                return data
            except json.JSONDecodeError:
                pass
        else:
            try:
                if json.loads(content):
                    return json.loads(content)
            except json.JSONDecodeError:
                pass
    return None

def tool_format_convert(mcp_tools: List[Dict[str, Any]], model: str) -> List[Dict[str, Any]]:
    if model.startswith("gpt"):
        return convert_to_openai_tools(mcp_tools)
    if model.startswith("gemini"):
        return convert_to_gemini_tools(mcp_tools)
    if model.startswith("claude"):
        return mcp_tools
    return convert_to_openai_tools(mcp_tools)

def read_yaml(path: Path) -> dict[str, Any]:
    if not path.exists():
        return {}
    if yaml is None:
        raise RuntimeError("PyYAML is required to read YAML config files. Install with `pip install pyyaml`.")
    with open(path, encoding="utf-8") as f:
        return yaml.safe_load(f) or {}

def read_json_file(file_path):
    """
    读取 JSON 文件
    :param file_path: JSON 文件路径
    :return: 解析后的字典/列表数据
    """
    try:
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"文件 {file_path} 不存在")
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        print("JSON 文件读取成功")
        return data
    except json.JSONDecodeError as e:
        print(f"JSON 文件格式错误: {e}")
    except Exception as e:
        print(f"读取 JSON 文件时出错: {e}")

def format_value_counts(df, key_column):
    # 计算计数和占比
    counts = df[key_column].value_counts()
    proportions = df[key_column].value_counts(normalize=True)

    # 合并为 DataFrame
    result = pd.DataFrame({
        'count': counts,
        'proportion': proportions,
    }).reset_index()

    # 重命名列
    result.columns = [key_column, 'count', 'proportion']

    # 可选：保留两位小数
    result['proportion'] = result['proportion'].apply(lambda x: f"{x * 100:.2f}%")

    total_count = result['count'].sum()

    # 添加总计行
    total_row = pd.DataFrame({
        key_column: ['Total'],
        'count': [total_count],
        'proportion': ['100%']
    })

    # 合并结果
    result = pd.concat([result, total_row], ignore_index=True)

    # print(result)
    return result     

from typing import Union, List, Dict
import pandas as pd
from datasets import Dataset

def pick_unique(dataset: Union[List[Dict], pd.DataFrame, Dataset], field: str, k: int = 4) -> Union[List[Dict], pd.DataFrame, Dataset]:
    """
    select K samples from dataset where the specific field values are all different.

    parameters：
        dataset: list[dict] / pandas.DataFrame / HuggingFace Dataset
        field: the unique field name
        k:  select how many elements

    """
    # list of dict
    if isinstance(dataset, list):
        seen = set()
        result = []
        for item in dataset:
            value = item[field]
            if value not in seen:
                seen.add(value)
                result.append(item)
            if len(result) == k:
                break
        return result

    # pandas.DataFrame
    elif isinstance(dataset, pd.DataFrame):
        return dataset.drop_duplicates(subset=[field]).head(k)

    # HuggingFace Dataset
    elif Dataset is not None and isinstance(dataset, Dataset):
        df = dataset.to_pandas().drop_duplicates(subset=[field]).head(k)
        return Dataset.from_pandas(df)

    else:
        raise TypeError("Unsupported dataset type: must be list[dict], pandas.DataFrame, or HuggingFace Dataset.")
    
# 语言检测 detect_language   标注 中英日德
import re
def detect_language(input_text):
    if isinstance(input_text, str):
        s = input_text.strip()
        # German check: e.g., contains ü, ö, ä, ß or typical German words
        if re.search(r'[üöäß]|[ÄÖÜ]', s) or re.search(r'\b(der|die|das|und|ein|nicht|ist|zu|in|den|mit|auf|für|sie|es|dem|von)\b', s, re.I):
            return 'ger'
        # Japanese check: hiragana, katakana, or frequent Japanese-specific patterns
        # Only classify as Japanese if contains **hiragana or katakana** (NOT CJK, which includes Chinese)
        if re.search(r'[\u3040-\u309F\u30A0-\u30FF]', s):
            return 'jap'
        # English check: contains [a-zA-Z] and high ASCII ratio, avoid misclassifying numbers/symbols
        if re.search(r'[a-zA-Z]', s):
            ascii_ratio = sum(1 for c in s if ord(c) < 128) / max(1, len(s))
            if ascii_ratio > 0.7:
                return 'en'
    # Default: assume Chinese if not above
    return 'zh'
    
# 填补language列为空的行
def complete_language_column(row):
    if isinstance(row['language'], str) and row['language'].strip():
        return row['language']
    else:
        return detect_language(row['input'])

if __name__ == "__main__":
    data = extract_format(content='```json\n{"a": 1}\n```')
    print(data)

    # 示例输入（你提供的 function_docs）
    function_docs = [
        {
            "type": "function",
            "function": {
                "name": "get_weather",
                "description": "Retrieves current weather for the given location.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "location": {"type": "string", "description": "City and country e.g. Bogotá, Colombia"},
                        "units": {"type": "string", "enum": ["celsius", "fahrenheit"], "description": "Units the temperature will be returned in."},
                    },
                    "required": ["location", "units"],
                    "additionalProperties": False,
                },
                "strict": True,
            },
        },
        {
            "type": "function",
            "function": {
                "name": "get_local_time",
                "description": "Get the local time of a given location",
                "strict": True,
                "parameters": {
                    "type": "object",
                    "required": ["location", "timezone"],
                    "properties": {
                        "location": {"type": "string", "description": "The name or coordinates of the location for which to get the local time"},
                        "timezone": {"type": "string", "description": "The timezone of the location, defaults to the location's timezone if not provided"},
                    },
                    "additionalProperties": False,
                },
            },
        },
    ]

    # 转换
    mcp_tools = convert_to_mcp_tools(function_docs)

    # 打印结果
    import json
    print(json.dumps(mcp_tools, indent=2, ensure_ascii=False))
    with open("function_docs.json", "w") as f:
        json.dump(mcp_tools, f, indent=2, ensure_ascii=False)
